***Циклы*** — это конструкции, которые позволяют выполнять один и тот же блок кода многократно, пока выполняется определенное условие.

## Цикл `for`

### Что такое цикл `for`?
***Цикл for*** используется для итерации по элементам последовательности (списку, строке, кортежу, словарю и другим итерируемым объектам).

### Базовый синтаксис
```python
for элемент in последовательность:
    # блок кода, выполняемый для каждого элемента
```

### Примеры использования

**1. Итерация по списку:**
```python
fruits = ['яблоко', 'банан', 'вишня']
for fruit in fruits:
    print(fruit)
```

**2. Итерация по строке:**
```python
for char in "Python":
    print(char)
```

**3. Использование `range()`:**
```python
for i in range(5):  # 0, 1, 2, 3, 4
    print(i)
```

**4. Цикл с условием:**
```python
numbers = [1, 3, 5, 7, 9]
for num in numbers:
    if num > 4:
        print(num, "больше 4")
```

## Цикл `while`

### Что такое цикл `while`?
***Цикл while*** выполняет блок кода, пока условие остается истинным.

### Базовый синтаксис
```python
while условие:
    # блок кода, выполняемый пока условие истинно
```

### Примеры использования

**1. Простой счетчик:**
```python
count = 0
while count < 5:
    print(count)
    count += 1
```

**2. Ввод до правильного ответа:**
```python
answer = ""
while answer != "да":
    answer = input("Вы согласны? (да/нет): ")
```

**3. Бесконечный цикл (с выходом по условию):**
```python
while True:
    user_input = input("Введите 'выход' для завершения: ")
    if user_input.lower() == 'выход':
        break
```

## Управление выполнением циклов

### Оператор `break`
Прерывает выполнение цикла полностью.

```python
for i in range(10):
    if i == 5:
        break
    print(i)  # Выведет числа от 0 до 4
```

### Оператор `continue`
Пропускает текущую итерацию и переходит к следующей.

```python
for i in range(5):
    if i == 2:
        continue
    print(i)  # Выведет 0, 1, 3, 4
```

### Оператор `else` в циклах
Блок `else` выполняется, если цикл завершился нормально (без `break`).

```python
for i in range(3):
    print(i)
else:
    print("Цикл завершен")  # Выполнится
```

## Полезные техники

**1. Вложенные циклы:**
```python
for i in range(3):
    for j in range(2):
        print(f"i={i}, j={j}")
```

**2. Генераторы списков (list comprehension):**
```python
squares = [x**2 for x in range(5)]  # [0, 1, 4, 9, 16]
```

**3. Итерация по словарю:**
```python
person = {'name': 'Alice', 'age': 25}
for key, value in person.items():
    print(f"{key}: {value}")
```

## Различия между `for` и `while`

| Характеристика | `for` | `while` |
|----------------|-------|---------|
| Когда использовать | Когда известно количество итераций | Когда условие выхода неизвестно заранее |
| Управление итерациями | Автоматическое | Ручное (нужно изменять условие) |
| Риск бесконечного цикла | Нет | Да |
| Использование с последовательностями | Да | Нет (требуется ручная индексация) |

## Практические советы

1. Избегайте бесконечных циклов в `while` — всегда убедитесь, что условие выхода достижимо
2. Для перебора элементов последовательности предпочитайте `for`
3. Используйте `enumerate()` для получения индексов в цикле `for`:
```python
for index, value in enumerate(['a', 'b', 'c']):
    print(index, value)
```
4. Для параллельного перебора нескольких последовательностей используйте `zip()`:
```python
names = ['Alice', 'Bob']
ages = [25, 30]
for name, age in zip(names, ages):
    print(name, age)
```


# Функции `range()`, `enumerate()`, `zip()` в Python

## Функция `range()`

***Range()*** — это встроенная функция Python, которая генерирует последовательность чисел.

### Основные формы:
1. `range(stop)` — от 0 до stop-1
2. `range(start, stop)` — от start до stop-1
3. `range(start, stop, step)` — от start до stop-1 с шагом step

### Особенности:
- Возвращает объект типа `range` (не список)
- Экономит память (генерирует числа по требованию)
- Работает только с целыми числами

### Примеры:
```python
# Базовые примеры
print(list(range(5)))         # [0, 1, 2, 3, 4]
print(list(range(2, 6)))      # [2, 3, 4, 5]
print(list(range(1, 10, 2)))  # [1, 3, 5, 7, 9]

# Отрицательный шаг
print(list(range(5, 0, -1)))  # [5, 4, 3, 2, 1]

# Использование в циклах
for i in range(3):
    print(i)  # 0, 1, 2
```

### Практическое применение:
- Итерация по индексам последовательности
- Генерация числовых последовательностей
- Создание циклов с заданным количеством повторений

## Функция `enumerate()`

***Enumerate()*** добавляет счетчик к итерируемому объекту.

### Синтаксис:
```python
enumerate(iterable, start=0)
```
где `start` — начальное значение счетчика

### Особенности:
- Возвращает объект-итератор с кортежами (индекс, элемент)
- Не создает список в памяти (ленивые вычисления)
- Удобна для работы с индексами в циклах

### Примеры:
```python
fruits = ['яблоко', 'банан', 'вишня']

# Базовый пример
for i, fruit in enumerate(fruits):
    print(i, fruit)
# 0 яблоко
# 1 банан
# 2 вишня

# С изменением стартового индекса
for i, fruit in enumerate(fruits, start=1):
    print(i, fruit)
# 1 яблоко
# 2 банан
# 3 вишня

# Преобразование в список
print(list(enumerate(fruits)))  # [(0, 'яблоко'), (1, 'банан'), (2, 'вишня')]
```

### Практическое применение:
- Когда нужны и индекс, и значение элемента
- Для создания словарей из списков с сохранением позиции
- При работе с файлами для нумерации строк

## Функция `zip()`

***Zip()*** объединяет элементы нескольких итерируемых объектов.

### Синтаксис:
```python
zip(*iterables)
```

### Особенности:
- Возвращает итератор из кортежей
- Останавливается при исчерпании самой короткой последовательности
- Может работать с любым количеством итерируемых объектов

### Примеры:
```python
names = ['Alice', 'Bob', 'Charlie']
ages = [24, 30, 28]

# Базовый пример
for name, age in zip(names, ages):
    print(f"{name}: {age} лет")
# Alice: 24 лет
# Bob: 30 лет
# Charlie: 28 лет

# Работа с тремя последовательностями
scores = [85, 92, 78]
for name, age, score in zip(names, ages, scores):
    print(f"{name}, {age} лет: оценка {score}")

# Преобразование в список
print(list(zip(names, ages)))  # [('Alice', 24), ('Bob', 30), ('Charlie', 28)]

# "Распаковка" zip-объекта
zipped = zip(names, ages)
unzipped_names, unzipped_ages = zip(*zipped)
print(unzipped_names)  # ('Alice', 'Bob', 'Charlie')
```

### Практическое применение:
- Параллельная обработка нескольких последовательностей
- Создание словарей из пар последовательностей
- Транспонирование матриц (поворот строк в столбцы)

## Сравнительная таблица

| Функция    | Возвращаемый тип | Основное назначение | Преимущества |
|------------|------------------|---------------------|--------------|
| `range()`  | `range` объект   | Генерация числовых последовательностей | Экономия памяти |
| `enumerate()` | итератор кортежей | Добавление индексов к элементам | Удобство работы с индексами |
| `zip()`    | итератор кортежей | Параллельная обработка последовательностей | Удобство работы с несколькими последовательностями |

## Продвинутые техники

### 1. Генерация словарей с `zip()`
```python
keys = ['name', 'age', 'job']
values = ['Alice', 25, 'Engineer']
person = dict(zip(keys, values))
# {'name': 'Alice', 'age': 25, 'job': 'Engineer'}
```

### 2. Комбинирование `enumerate()` и `zip()`
```python
for i, (name, age) in enumerate(zip(names, ages), start=1):
    print(f"{i}. {name}: {age}")
```

### 3. `zip_longest()` из itertools (для последовательностей разной длины)
```python
from itertools import zip_longest

a = [1, 2, 3]
b = ['a', 'b']
for x in zip_longest(a, b, fillvalue=None):
    print(x)
# (1, 'a')
# (2, 'b')
# (3, None)
```

## Ограничения и подводные камни

1. **Объекты одноразовые**:
   ```python
   r = range(5)
   print(list(r))  # [0, 1, 2, 3, 4]
   print(list(r))  # [0, 1, 2, 3, 4] (работает)
   
   z = zip(names, ages)
   print(list(z))  # [('Alice', 24), ...]
   print(list(z))  # [] (второй раз не работает!)
   ```

2. **Проблема с разной длиной в `zip()`**:
   ```python
   list(zip([1, 2, 3], ['a', 'b']))  # [(1, 'a'), (2, 'b')]
   ```

3. **`range()` не поддерживает float**:
   ```python
   # Так не работает:
   range(0.1, 5.0, 0.5)  # TypeError
   ```

